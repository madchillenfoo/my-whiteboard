<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://www.gstatic.com https://*.firebaseio.com; connect-src 'self' https://*.firebaseio.com wss://*.firebaseio.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https: http:;">
    <title>Collaborative Whiteboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow: hidden;
            background: #1a1a1a;
        }
        
        #toolbar {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
            position: relative;
        }
        
        /* BRANDING SECTION */
        #brandingArea {
            background: rgba(255,255,255,0.15);
            padding: 8px 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 10px;
            margin-right: auto;
        }

        #brandingImage {
            max-height: 35px;
            max-width: 150px;
            height: auto;
            width: auto;
            object-fit: contain;
            display: block;
        }

        #brandingText {
            color: white;
            font-size: 16px;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            white-space: nowrap;
        }
        
        .tool-group {
            display: flex;
            gap: 10px;
            align-items: center;
            background: rgba(255,255,255,0.1);
            padding: 8px 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        label {
            color: white;
            font-size: 14px;
            font-weight: 600;
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        input[type="color"] {
            width: 50px;
            height: 40px;
            border: 3px solid white;
            border-radius: 8px;
            cursor: pointer;
            background: none;
        }
        
        input[type="range"] {
            width: 120px;
            height: 6px;
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        select {
            padding: 8px 12px;
            border-radius: 8px;
            border: none;
            background: white;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        button {
            padding: 10px 20px;
            background: rgba(255,255,255,0.9);
            color: #667eea;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 700;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        button:hover {
            background: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .tool-btn {
            width: 45px;
            height: 45px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            background: rgba(255,255,255,0.9);
        }
        
        .tool-btn.active {
            background: white;
            border: 3px solid #ffd700;
            transform: scale(1.1);
        }
        
        #canvas {
            display: block;
            background: white;
            cursor: crosshair;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.1);
        }
        
        #currentColor {
            width: 30px;
            height: 30px;
            border: 3px solid white;
            border-radius: 50%;
            display: inline-block;
            vertical-align: middle;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        .size-display {
            color: white;
            font-weight: 700;
            min-width: 35px;
            text-align: center;
            font-size: 16px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        #clearBtn {
            background: #ff6b6b;
            color: white;
        }
        
        #clearBtn:hover {
            background: #ff5252;
        }

        #saveBtn {
            background: #27ae60;
            color: white;
        }

        #saveBtn:hover {
            background: #229954;
        }

        #statusInfo {
            background: rgba(255,255,255,0.15);
            padding: 8px 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            display: flex;
            gap: 15px;
            align-items: center;
        }

        #onlineUsers {
            color: white;
            font-weight: 700;
            font-size: 14px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        #statusText {
            color: white;
            font-weight: 700;
            font-size: 14px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .status-connected {
            color: #2ecc71 !important;
        }

        .status-disconnected {
            color: #e74c3c !important;
        }

        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            color: white;
            font-size: 24px;
            font-weight: 700;
        }

        #loadingOverlay.hidden {
            display: none;
        }

        .remote-cursor {
            position: fixed;
            pointer-events: none;
            z-index: 9998;
            transition: transform 0.1s ease;
        }

        .cursor-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff6b6b;
            border: 2px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        #saveModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        #saveModal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            max-width: 400px;
            width: 90%;
        }

        .modal-content h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 24px;
        }

        .format-option {
            background: #f8f9fa;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .format-option:hover {
            background: #e9ecef;
            border-color: #667eea;
            transform: translateX(5px);
        }

        .format-option strong {
            color: #667eea;
            font-size: 16px;
        }

        .format-option p {
            color: #666;
            font-size: 14px;
            margin-top: 5px;
        }

        .modal-close {
            background: #e9ecef;
            color: #666;
            margin-top: 20px;
            width: 100%;
        }

        .modal-close:hover {
            background: #dee2e6;
        }
    </style>
</head>
<body>
    <div id="loadingOverlay">
        <div>üé® Loading whiteboard...</div>
    </div>

    <div id="saveModal">
        <div class="modal-content">
            <h2>üíæ Save Your Artwork</h2>
            <p style="color: #666; margin-bottom: 20px;">Choose your preferred format:</p>
            
            <div class="format-option" onclick="saveCanvas('png')">
                <strong>üñºÔ∏è PNG (Transparent)</strong>
                <p>Best for sharing online or editing later</p>
            </div>
            
            <div class="format-option" onclick="saveCanvas('jpg')">
                <strong>üì∏ JPG (Smaller file)</strong>
                <p>Best for printing or uploading</p>
            </div>
            
            <button class="modal-close" onclick="closeModal()">Cancel</button>
        </div>
    </div>

    <div id="toolbar">
        <!-- BRANDING - Replace with your image URL or text -->
        <div id="brandingArea">
            <!-- <img id="brandingImage" src="YOUR_IMAGE_URL_HERE.png" alt="Logo"> -->
            
            <!-- Option 2: Use text (currently active) -->
            <span id="brandingText">üé® $DRAW</span>
        </div>

        <div class="tool-group">
            <label>Tool:</label>
            <button class="tool-btn active" data-tool="brush" title="Brush">üñåÔ∏è</button>
            <button class="tool-btn" data-tool="eraser" title="Eraser">üßº</button>
            <button class="tool-btn" data-tool="fill" title="Fill Bucket">ü™£</button>
            <button class="tool-btn" data-tool="eyedropper" title="Eyedropper">üìç</button>
        </div>
        
        <div class="tool-group">
            <label>Color:</label>
            <input type="color" id="colorPicker" value="#000000">
            <span id="currentColor"></span>
        </div>
        
        <div class="tool-group">
            <label>Thickness:</label>
            <input type="range" id="brushSize" min="1" max="50" value="5">
            <span class="size-display" id="sizeDisplay">5</span>
        </div>
        
        <div class="tool-group">
            <label>Brush Style:</label>
            <select id="brushStyle">
                <option value="round">‚óè Round</option>
                <option value="square">‚ñ† Square</option>
                <option value="spray">‚ú¶ Spray</option>
                <option value="calligraphy">‚úçÔ∏è Calligraphy</option>
                <option value="marker">üñäÔ∏è Marker</option>
                <option value="pencil">‚úèÔ∏è Pencil</option>
                <option value="charcoal">üñ§ Charcoal</option>
                <option value="neon">‚ú® Neon Glow</option>
                <option value="airbrush">üí® Airbrush</option>
                <option value="sketch">üìù Sketch</option>
                <option value="watercolor">üé® Watercolor</option>
                <option value="crayon">üñçÔ∏è Crayon</option>
            </select>
        </div>
        
        <button id="saveBtn">üíæ Save</button>
        <button id="clearBtn">üóëÔ∏è Clear Canvas</button>

        <div id="statusInfo">
            <span id="onlineUsers">üë• Online: 1</span>
            <span>‚Ä¢</span>
            <span id="statusText" class="status-disconnected">Connecting...</span>
        </div>
    </div>
    
    <canvas id="canvas"></canvas>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, onValue, onChildAdded, onChildChanged, onChildRemoved, push, onDisconnect, remove } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';
        
        const firebaseConfig = {
            apiKey: "AIzaSyC1MfaEohiAtPkH5bbxINqqkRoYEBZ4B6A",
            authDomain: "whiteboard-d6357.firebaseapp.com",
            databaseURL: "https://whiteboard-d6357-default-rtdb.firebaseio.com",
            projectId: "whiteboard-d6357",
            storageBucket: "whiteboard-d6357.firebasestorage.app",
            messagingSenderId: "124637106374",
            appId: "1:124637106374:web:081d50ffbf7b5dcda607c7"
        };
        
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const loadingOverlay = document.getElementById('loadingOverlay');
        const saveModal = document.getElementById('saveModal');
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - document.getElementById('toolbar').offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        document.getElementById('saveBtn').addEventListener('click', () => {
            saveModal.classList.add('show');
        });
        
        window.closeModal = function() {
            saveModal.classList.remove('show');
        }
        
        window.saveCanvas = function(format) {
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            
            if (format === 'png') {
                link.download = `whiteboard-${timestamp}.png`;
                link.href = canvas.toDataURL('image/png');
            } else if (format === 'jpg') {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCtx.fillStyle = '#FFFFFF';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                tempCtx.drawImage(canvas, 0, 0);
                
                link.download = `whiteboard-${timestamp}.jpg`;
                link.href = tempCanvas.toDataURL('image/jpeg', 0.95);
            }
            
            link.click();
            closeModal();
        }
        
        saveModal.addEventListener('click', (e) => {
            if (e.target === saveModal) {
                closeModal();
            }
        });
        
        let currentTool = 'brush';
        let currentColor = '#000000';
        let brushSize = 5;
        let brushStyle = 'round';
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        
        const userId = 'user_' + Math.random().toString(36).substr(2, 9);
        
        const remoteCursors = new Map();
        
        function createCursorElement(userId, color) {
            const cursor = document.createElement('div');
            cursor.className = 'remote-cursor';
            cursor.id = `cursor-${userId}`;
            
            const dot = document.createElement('div');
            dot.className = 'cursor-dot';
            dot.style.background = color;
            
            cursor.appendChild(dot);
            document.body.appendChild(cursor);
            
            return cursor;
        }
        
        function updateCursor(userId, x, y, color) {
            if (userId === window.userId) return;
            
            let cursor = remoteCursors.get(userId);
            if (!cursor) {
                cursor = createCursorElement(userId, color);
                remoteCursors.set(userId, cursor);
            }
            
            cursor.style.transform = `translate(${x}px, ${y}px)`;
            cursor.querySelector('.cursor-dot').style.background = color;
        }
        
        function removeCursor(userId) {
            const cursor = remoteCursors.get(userId);
            if (cursor) {
                cursor.remove();
                remoteCursors.delete(userId);
            }
        }
        
        const toolButtons = document.querySelectorAll('.tool-btn');
        const colorPicker = document.getElementById('colorPicker');
        const currentColorDisplay = document.getElementById('currentColor');
        const brushSizeInput = document.getElementById('brushSize');
        const sizeDisplay = document.getElementById('sizeDisplay');
        const brushStyleSelect = document.getElementById('brushStyle');
        const clearBtn = document.getElementById('clearBtn');
        const onlineUsersDiv = document.getElementById('onlineUsers');
        const statusText = document.getElementById('statusText');
        
        function updateColorDisplay() {
            currentColorDisplay.style.backgroundColor = currentColor;
        }
        updateColorDisplay();
        
        toolButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                toolButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTool = btn.dataset.tool;
                
                if (currentTool === 'eyedropper') {
                    canvas.style.cursor = 'crosshair';
                } else if (currentTool === 'fill') {
                    canvas.style.cursor = 'pointer';
                } else {
                    canvas.style.cursor = 'crosshair';
                }
            });
        });
        
        colorPicker.addEventListener('change', (e) => {
            currentColor = e.target.value;
            updateColorDisplay();
        });
        
        brushSizeInput.addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            sizeDisplay.textContent = brushSize;
        });
        
        brushStyleSelect.addEventListener('change', (e) => {
            brushStyle = e.target.value;
        });
        
        clearBtn.addEventListener('click', () => {
            if (confirm('Clear the entire canvas? This will affect all users!')) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                set(ref(database, 'clearCanvas'), Date.now());
                set(ref(database, 'drawings'), null);
            }
        });
        
        const userRef = ref(database, 'users/' + userId);
        set(userRef, { 
            online: true, 
            cursorX: 0,
            cursorY: 0,
            color: currentColor,
            timestamp: Date.now()
        });
        
        onDisconnect(userRef).remove();
        
        let lastCursorUpdate = 0;
        canvas.addEventListener('mousemove', (e) => {
            const now = Date.now();
            if (now - lastCursorUpdate < 50) return;
            
            lastCursorUpdate = now;
            const x = e.clientX;
            const y = e.clientY;
            
            set(userRef, {
                online: true,
                cursorX: x,
                cursorY: y,
                color: currentColor,
                timestamp: now
            });
        });
        
        onChildAdded(ref(database, 'users'), (snapshot) => {
            const data = snapshot.val();
            const otherUserId = snapshot.key;
            if (otherUserId !== userId && data.cursorX && data.cursorY) {
                updateCursor(otherUserId, data.cursorX, data.cursorY, data.color);
            }
        });
        
        onChildChanged(ref(database, 'users'), (snapshot) => {
            const data = snapshot.val();
            const otherUserId = snapshot.key;
            if (otherUserId !== userId && data.cursorX && data.cursorY) {
                updateCursor(otherUserId, data.cursorX, data.cursorY, data.color);
            }
        });
        
        onChildRemoved(ref(database, 'users'), (snapshot) => {
            const otherUserId = snapshot.key;
            removeCursor(otherUserId);
        });
        
        onValue(ref(database, 'users'), (snapshot) => {
            const users = snapshot.val();
            const count = users ? Object.keys(users).length : 0;
            onlineUsersDiv.textContent = `üë• Online: ${count}`;
        });
        
        onValue(ref(database, 'clearCanvas'), (snapshot) => {
            const timestamp = snapshot.val();
            if (timestamp) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        });
        
        function drawLine(x1, y1, x2, y2, color, size, style, tool) {
            if (tool === 'eraser') {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = size;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                return;
            }
            
            switch(style) {
                case 'round':
                    ctx.strokeStyle = color;
                    ctx.lineWidth = size;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    break;
                    
                case 'square':
                    ctx.strokeStyle = color;
                    ctx.lineWidth = size;
                    ctx.lineCap = 'square';
                    ctx.lineJoin = 'miter';
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    break;
                    
                case 'spray':
                    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                    const steps = Math.max(distance / 2, 1);
                    for (let i = 0; i < steps; i++) {
                        const t = i / steps;
                        const x = x1 + (x2 - x1) * t;
                        const y = y1 + (y2 - y1) * t;
                        for (let j = 0; j < 10; j++) {
                            const offsetX = (Math.random() - 0.5) * size * 2;
                            const offsetY = (Math.random() - 0.5) * size * 2;
                            ctx.fillStyle = color;
                            ctx.fillRect(x + offsetX, y + offsetY, 2, 2);
                        }
                    }
                    break;
                    
                case 'calligraphy':
                    // Proper calligraphy effect - angled flat brush
                    ctx.save();
                    
                    // Calculate angle of stroke
                    const angle = Math.atan2(y2 - y1, x2 - x1);
                    
                    // Draw with varying width based on angle
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 0) {
                        // Create gradient width effect
                        const perpAngle = angle + Math.PI / 2;
                        const width1 = size * 0.5;
                        const width2 = size * 1.5;
                        
                        ctx.strokeStyle = color;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        
                        // Main stroke with variable width
                        ctx.lineWidth = size + Math.abs(Math.sin(angle)) * size * 0.8;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                    break;
                    
                case 'marker':
                    ctx.strokeStyle = color;
                    ctx.lineWidth = size;
                    ctx.lineCap = 'round';
                    ctx.globalAlpha = 0.7;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                    break;
                    
                case 'pencil':
                    const pencilDistance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                    const pencilSteps = Math.max(pencilDistance, 1);
                    for (let i = 0; i < pencilSteps; i++) {
                        const t = i / pencilSteps;
                        const x = x1 + (x2 - x1) * t;
                        const y = y1 + (y2 - y1) * t;
                        ctx.fillStyle = color;
                        ctx.globalAlpha = 0.3 + Math.random() * 0.4;
                        ctx.fillRect(x + (Math.random() - 0.5), y + (Math.random() - 0.5), size / 3, size / 3);
                    }
                    ctx.globalAlpha = 1.0;
                    break;
                    
                case 'charcoal':
                    const charcoalDistance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                    const charcoalSteps = Math.max(charcoalDistance / 2, 1);
                    for (let i = 0; i < charcoalSteps; i++) {
                        const t = i / charcoalSteps;
                        const x = x1 + (x2 - x1) * t;
                        const y = y1 + (y2 - y1) * t;
                        for (let j = 0; j < 5; j++) {
                            const offsetX = (Math.random() - 0.5) * size;
                            const offsetY = (Math.random() - 0.5) * size;
                            ctx.fillStyle = color;
                            ctx.globalAlpha = 0.1 + Math.random() * 0.3;
                            ctx.fillRect(x + offsetX, y + offsetY, size / 2, size / 2);
                        }
                    }
                    ctx.globalAlpha = 1.0;
                    break;
                    
                case 'neon':
                    ctx.strokeStyle = color;
                    ctx.lineWidth = size;
                    ctx.lineCap = 'round';
                    ctx.shadowBlur = size * 3;
                    ctx.shadowColor = color;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    break;
                    
                case 'airbrush':
                    const airDistance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                    const airSteps = Math.max(airDistance / 2, 1);
                    for (let i = 0; i < airSteps; i++) {
                        const t = i / airSteps;
                        const x = x1 + (x2 - x1) * t;
                        const y = y1 + (y2 - y1) * t;
                        for (let j = 0; j < 20; j++) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = Math.random() * size * 1.5;
                            const offsetX = Math.cos(angle) * radius;
                            const offsetY = Math.sin(angle) * radius;
                            ctx.fillStyle = color;
                            ctx.globalAlpha = 0.05;
                            ctx.fillRect(x + offsetX, y + offsetY, 1, 1);
                        }
                    }
                    ctx.globalAlpha = 1.0;
                    break;
                    
                case 'sketch':
                    ctx.strokeStyle = color;
                    ctx.lineWidth = size / 2;
                    ctx.lineCap = 'round';
                    ctx.globalAlpha = 0.6;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(x1 + (Math.random() - 0.5) * 2, y1 + (Math.random() - 0.5) * 2);
                        ctx.lineTo(x2 + (Math.random() - 0.5) * 2, y2 + (Math.random() - 0.5) * 2);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1.0;
                    break;
                    
                case 'watercolor':
                    const waterDistance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                    const waterSteps = Math.max(waterDistance / 3, 1);
                    for (let i = 0; i < waterSteps; i++) {
                        const t = i / waterSteps;
                        const x = x1 + (x2 - x1) * t;
                        const y = y1 + (y2 - y1) * t;
                        ctx.fillStyle = color;
                        ctx.globalAlpha = 0.1;
                        ctx.beginPath();
                        ctx.arc(x, y, size * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1.0;
                    break;
                    
                case 'crayon':
                    const crayonDistance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                    const crayonSteps = Math.max(crayonDistance, 1);
                    for (let i = 0; i < crayonSteps; i++) {
                        const t = i / crayonSteps;
                        const x = x1 + (x2 - x1) * t;
                        const y = y1 + (y2 - y1) * t;
                        if (Math.random() > 0.3) {
                            ctx.fillStyle = color;
                            ctx.globalAlpha = 0.5 + Math.random() * 0.3;
                            ctx.fillRect(
                                x + (Math.random() - 0.5) * size,
                                y + (Math.random() - 0.5) * size,
                                size / 2,
                                size / 2
                            );
                        }
                    }
                    ctx.globalAlpha = 1.0;
                    break;
            }
        }
        
        function floodFill(startX, startY, fillColor) {
            startX = Math.floor(startX);
            startY = Math.floor(startY);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const targetColor = getPixelColor(imageData, startX, startY);
            const fillColorRgb = hexToRgb(fillColor);
            
            if (colorsMatch(targetColor, fillColorRgb)) return;
            
            const pixelsToCheck = [[startX, startY]];
            const checkedPixels = new Set();
            
            while (pixelsToCheck.length > 0) {
                const [x, y] = pixelsToCheck.pop();
                const key = `${x},${y}`;
                
                if (checkedPixels.has(key)) continue;
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) continue;
                
                const currentColor = getPixelColor(imageData, x, y);
                
                if (!colorsMatch(currentColor, targetColor)) continue;
                
                setPixelColor(imageData, x, y, fillColorRgb);
                checkedPixels.add(key);
                
                pixelsToCheck.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        function getPixelColor(imageData, x, y) {
            const index = (y * imageData.width + x) * 4;
            return [
                imageData.data[index],
                imageData.data[index + 1],
                imageData.data[index + 2],
                imageData.data[index + 3]
            ];
        }
        
        function setPixelColor(imageData, x, y, color) {
            const index = (y * imageData.width + x) * 4;
            imageData.data[index] = color[0];
            imageData.data[index + 1] = color[1];
            imageData.data[index + 2] = color[2];
            imageData.data[index + 3] = 255;
        }
        
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
        }
        
        function rgbToHex(r, g, b) {
            return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        
        function colorsMatch(a, b) {
            return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
        }
        
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }
        
        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.touches[0].clientX - rect.left,
                y: e.touches[0].clientY - rect.top
            };
        }
        
        function startDrawing(e) {
            e.preventDefault();
            isDrawing = true;
            
            const pos = e.touches ? getTouchPos(e) : getMousePos(e);
            lastX = pos.x;
            lastY = pos.y;
            
            if (currentTool === 'fill') {
                floodFill(pos.x, pos.y, currentColor);
                saveToFirebase(pos.x, pos.y, pos.x, pos.y, 'fill');
            } else if (currentTool === 'eyedropper') {
                const pixel = ctx.getImageData(Math.floor(pos.x), Math.floor(pos.y), 1, 1).data;
                currentColor = rgbToHex(pixel[0], pixel[1], pixel[2]);
                colorPicker.value = currentColor;
                updateColorDisplay();
            } else {
                drawLine(pos.x, pos.y, pos.x, pos.y, currentColor, brushSize, brushStyle, currentTool);
                saveToFirebase(pos.x, pos.y, pos.x, pos.y, 'start');
            }
        }
        
        function draw(e) {
            if (!isDrawing || currentTool === 'fill' || currentTool === 'eyedropper') return;
            e.preventDefault();
            
            const pos = e.touches ? getTouchPos(e) : getMousePos(e);
            
            drawLine(lastX, lastY, pos.x, pos.y, currentColor, brushSize, brushStyle, currentTool);
            saveToFirebase(lastX, lastY, pos.x, pos.y, 'draw');
            
            lastX = pos.x;
            lastY = pos.y;
        }
        
        function stopDrawing(e) {
            if (isDrawing) {
                isDrawing = false;
            }
        }
        
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);
        
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);
        
        function saveToFirebase(x1, y1, x2, y2, action) {
            const drawRef = ref(database, 'drawings');
            push(drawRef, {
                x1, y1, x2, y2, action,
                color: currentColor,
                size: brushSize,
                tool: currentTool,
                style: brushStyle,
                timestamp: Date.now(),
                userId: userId
            });
        }
        
        let hasLoadedExistingDrawings = false;
        
        onValue(ref(database, 'drawings'), (snapshot) => {
            if (hasLoadedExistingDrawings) return;
            
            const draws = snapshot.val();
            if (draws) {
                const sortedDraws = Object.entries(draws).sort((a, b) => a[1].timestamp - b[1].timestamp);
                
                sortedDraws.forEach(([key, data]) => {
                    if (data.action === 'fill') {
                        floodFill(data.x1, data.y1, data.color);
                    } else {
                        drawLine(data.x1, data.y1, data.x2, data.y2, data.color, data.size, data.style, data.tool);
                    }
                });
            }
            
            hasLoadedExistingDrawings = true;
            loadingOverlay.classList.add('hidden');
            statusText.textContent = 'Connected';
            statusText.className = 'status-connected';
        }, { onlyOnce: true });
        
        setTimeout(() => {
            onChildAdded(ref(database, 'drawings'), (snapshot) => {
                if (!hasLoadedExistingDrawings) return;
                
                const data = snapshot.val();
                if (data.userId === userId) return;
                
                if (data.action === 'fill') {
                    floodFill(data.x1, data.y1, data.color);
                } else {
                    drawLine(data.x1, data.y1, data.x2, data.y2, data.color, data.size, data.style, data.tool);
                }
            });
        }, 2000);
        
        setInterval(() => {
            onValue(ref(database, 'drawings'), (snapshot) => {
                const draws = snapshot.val();
                if (!draws) return;
                
                const drawArray = Object.entries(draws);
                if (drawArray.length > 10000) {
                    drawArray.sort((a, b) => a[1].timestamp - b[1].timestamp);
                    const toRemove = drawArray.slice(0, drawArray.length - 10000);
                    toRemove.forEach(([key]) => {
                        remove(ref(database, 'drawings/' + key));
                    });
                }
            }, { onlyOnce: true });
        }, 300000);
        
        window.userId = userId;
        console.log('üé® Whiteboard Ready! User ID:', userId);
    </script>
</body>
</html>
